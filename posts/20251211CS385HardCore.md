---
title: CS385 Lab Exam 3: 10 Challenging Practice Questions
title_en: CS385 Lab Exam 3: 10 Challenging Practice Questions
title_zh: CS385 å®éªŒè€ƒè¯• 3ï¼š10 é“æŒ‘æˆ˜æ€§ç»ƒä¹ é¢˜
date: 2025-12-11
categories: CS385
tags: Advanced Quiz, React Internals, JS Pitfalls
summary_en: A collection of 10 practice questions covering Shallow Copies, Stale Closures, Reduce logic, and Object mutations. These helped me identify gaps in my understanding before the exam.
summary_zh: 10 é“ç»ƒä¹ é¢˜ï¼Œè¦†ç›–æµ…æ‹·è´é™·é˜±ã€é—­åŒ…è¿‡æœŸã€Reduce é€»è¾‘åŠå¯¹è±¡å˜å¼‚ã€‚è¿™äº›é¢˜ç›®å¸®åŠ©æˆ‘åœ¨è€ƒå‰æŸ¥æ¼è¡¥ç¼ºã€‚
---

[EN]

# ğŸ“ 10 Challenging Practice Questions

I compiled these questions to test my understanding of some trickier JavaScript and React concepts. They cover edge cases that are easy to miss.

---

### Q1: The Shallow Copy Trap

You are updating a nested object using the spread operator.

```javascript
const state = {
  user: { name: "Dong", score: 10 },
  active: true,
};
const newState = { ...state };

newState.user.score = 20; // Direct mutation
newState.active = false;

console.log(state.user.score, state.active);
```

**What is the output of the ORIGINAL `state`?**

A) `10, true`
B) `20, true`
C) `20, false`
D) `10, false`

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: B** `20, true`

**Rationale:** The spread operator `{...state}` creates a **Shallow Copy**.

1.  Top-level primitives (`active`) are copied by value. Changing `newState.active` does NOT affect `state.active`.
2.  Nested objects (`user`) are copied by **Reference**. `newState.user` points to the SAME memory address as `state.user`. Modifying it mutates the original!

</details>

---

### Q2: The "Stale Closure" in Event Handlers

```javascript
const [count, setCount] = useState(0);

const handleClick = () => {
  setCount(count + 1);
  setCount(count + 1);
  setCount(count + 1);
};
// User clicks the button ONCE.
```

**What is the final value of `count` rendered?**

A) 3
B) 1
C) 0
D) undefined

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: B** `1`

**Rationale:** Inside the function scope, `count` is `0` for all three calls.
React queues: `setCount(0 + 1)`, `setCount(0 + 1)`, `setCount(0 + 1)`.
They overwrite each other. To fix this, use the functional update: `setCount(prev => prev + 1)`.

</details>

---

### Q3: `reduce` with Initial Value Nuance

```javascript
const nums = [1, 2, 3];
const result = nums.reduce((acc, curr) => {
  if (curr > 1) acc.push(curr * 2);
  return acc;
}, []); // Note the initial value
```

**What is `result`?**

A) `[2, 4, 6]`
B) `[4, 6]`
C) `6` (Sum)
D) Error: `push` returns length

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: B** `[4, 6]`

**Rationale:**

1.  Initial value is `[]`.
2.  Iteration 1: `curr` is 1. Condition fails. Returns `[]`.
3.  Iteration 2: `curr` is 2. `acc.push(4)`. Returns `[4]`.
4.  Iteration 3: `curr` is 3. `acc.push(6)`. Returns `[4, 6]`.
    _Trap:_ If you did `return acc.push(...)`, it would fail because `.push()` returns the new length (integer), not the array.

</details>

---

### Q4: Destructuring with Renaming & Defaults

```javascript
const obj = { x: 10, z: 5 };
const { x: newX, y = 20 } = obj;

console.log(x);
```

**What is the output?**

A) `10`
B) `undefined`
C) `ReferenceError`
D) `20`

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: C** `ReferenceError`

**Rationale:** You renamed `x` to `newX`. The variable `x` is **NOT** defined in the current scope. Only `newX` and `y` exist as variables.

</details>

---

### Q5: `JSON.stringify` Data Loss

You try to debug an object by rendering it stringified.

```javascript
const data = {
  id: 1,
  process: () => console.log("running"),
  value: undefined,
};
return <div>{JSON.stringify(data)}</div>;
```

**What is rendered?**

A) `{"id":1, "process": "() => ...", "value": undefined}`
B) `{"id":1}`
C) `{"id":1, "value": null}`
D) Error

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: B** `{"id":1}`

**Rationale:** `JSON.stringify` **ignores** (strips out) properties that are `function` or `undefined`. They vanish from the JSON string. `null` would be preserved.

</details>

---

### Q6: The "Short-Circuit" Rendering Math

```javascript
const items = [];
// Scenario: We want to show "No items" if empty.
return (
  <div>
    {items.length && <List data={items} />}
    {!items.length && "No items"}
  </div>
);
```

**What is ACTUALLY rendered when empty?**

A) `No items`
B) `0No items`
C) `falseNo items`
D) Nothing

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: B** `0No items`

**Rationale:**
Line 1: `items.length` is `0`. `0 && <List...>` evaluates to `0`. React renders `0`.
Line 2: `!0` is `true`. `true && "No items"` evaluates to `"No items"`.
Result: `0` + `No items`.
_Fix:_ Use `items.length > 0` or ternary operator.

</details>

---

### Q7: Weird Array Keys

```javascript
const arr = ["A", "B"];
arr["2"] = "C";
arr.foo = "D";

console.log(arr.length);
```

**What is the length?**

A) 4
B) 3
C) 2
D) undefined

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: B** `3`

**Rationale:**

1.  Arrays are Objects. You can add properties like `foo`.
2.  `arr["2"]` is a valid numeric index. It extends the array length to 3 (`0, 1, 2`).
3.  `arr.foo` is a property, but **does not affect the length** of the array.

</details>

---

### Q8: `useEffect` Cleanup Timing

```javascript
useEffect(() => {
  console.log("Mount");
  return () => console.log("Unmount");
}, [id]);
// Scenario: id changes from 1 to 2.
```

**What is the console order?**

A) Mount (1) -> Mount (2) -> Unmount (1)
B) Unmount (1) -> Mount (2)
C) Mount (2) -> Unmount (1)
D) Mount (1) -> Unmount (1) -> Mount (2)

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: B** `Unmount (1) -> Mount (2)`

**Rationale:** When a dependency changes:

1.  React cleans up the **previous** effect first (runs the return function with old data).
2.  Then runs the **new** effect (with new data).

</details>

---

### Q9: Object Key Order in `map`

```javascript
const obj = { 2: "a", 1: "b", b: "c", a: "d" };
// We map over Object.keys(obj)
```

**What is the likely iteration order of keys?**

A) "2", "1", "b", "a" (Insertion Order)
B) "1", "2", "b", "a" (Numeric sorted, then strings)
C) Random
D) "a", "b", "1", "2" (Alphabetical)

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: B** `"1", "2", "b", "a"`

**Rationale:** This is a deep JS spec rule.

1.  **Integer-like keys** (indices) are sorted ascending first (`"1", "2"`).
2.  **String keys** follow in insertion order (`"b", "a"`).
    _Note:_ This traps people who think JSON preserves insertion order perfectly.

</details>

---

### Q10: The `filter` + `map` Chain Efficiency

You want to render only active users.

```javascript
// Method A
users.filter((u) => u.active).map((u) => <div key={u.id}>{u.name}</div>);

// Method B
users.map((u) => u.active && <div key={u.id}>{u.name}</div>);
```

**What is the difference in the DOM output?**

A) No difference.
B) Method A renders a clean list; Method B renders `false` holes.
C) Method B renders `null` holes in the DOM.
D) Method B is faster.

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">â–¼ Click to Reveal Answer</summary>

âœ… **Correct Answer: A** (Visually) / **B** (Technically)

**Rationale:**
React ignores `false` returned by Method B, so visually they look the same.
**HOWEVER**, Method B creates an array of mixed `JSX` and `false` values (e.g. `[<div>...</div>, false, <div>...</div>]`).
Method A creates a shorter, cleaner array `[<div>...</div>, <div>...</div>]`.
Method A is generally preferred for cleaner keys and index handling.

</details>

---

[ZH]
**æ€»ç»“**
**è¿™äº›é¢˜ç›®æ¶µç›–äº†æˆ‘åœ¨å¤ä¹ è¿‡ç¨‹ä¸­é‡åˆ°çš„ä¸€äº›ç›²ç‚¹ã€‚å¦‚æœèƒ½ç†è§£è¿™äº›æ¦‚å¿µï¼Œå¯¹æ˜å¤©çš„è€ƒè¯•ä¼šæ›´æœ‰ä¿¡å¿ƒã€‚**
**Conclusion**
**These questions cover some blind spots I encountered during my review. Understanding these concepts gives me more confidence for tomorrow's exam.**
[END]
