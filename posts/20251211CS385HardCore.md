---
title: CS385 Lab Exam 3: The "Hardcore" 10
title_en: CS385 Lab Exam 3: The "Hardcore" 10
title_zh: CS385 炼狱十题：挑战满分极限
date: 2025-12-11
categories: CS385
tags: Advanced Quiz, React Internals, JS Pitfalls
summary_en: 10 advanced questions covering Shallow Copies, Stale Closures, Reduce logic, and tricky Object mutations. Not for the faint of heart.
summary_zh: 10 道高难度题目，覆盖浅拷贝陷阱、闭包过期、Reduce 逻辑及复杂的对象变异。心脏不好者慎入。
---

[EN]
# ☠️ The "Hardcore" 10
These questions are designed to trick you. Read every character.
**Rules:** If you get > 8/10, you are ready to teach the class.

---

### Q1: The Shallow Copy Trap
You are updating a nested object using the spread operator.
```javascript
const state = { 
  user: { name: "Dong", score: 10 }, 
  active: true 
};
const newState = { ...state };

newState.user.score = 20; // Direct mutation
newState.active = false;

console.log(state.user.score, state.active);
```
**What is the output of the ORIGINAL `state`?**

A) `10, true`
B) `20, true`
C) `20, false`
D) `10, false`

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: B** `20, true`

**Rationale:** The spread operator `{...state}` creates a **Shallow Copy**.
1.  Top-level primitives (`active`) are copied by value. Changing `newState.active` does NOT affect `state.active`.
2.  Nested objects (`user`) are copied by **Reference**. `newState.user` points to the SAME memory address as `state.user`. Modifying it mutates the original!

</details>

---

### Q2: The "Stale Closure" in Event Handlers
```javascript
const [count, setCount] = useState(0);

const handleClick = () => {
  setCount(count + 1);
  setCount(count + 1);
  setCount(count + 1);
};
// User clicks the button ONCE.
```
**What is the final value of `count` rendered?**

A) 3
B) 1
C) 0
D) undefined

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: B** `1`

**Rationale:** Inside the function scope, `count` is `0` for all three calls.
React queues: `setCount(0 + 1)`, `setCount(0 + 1)`, `setCount(0 + 1)`.
They overwrite each other. To fix this, use the functional update: `setCount(prev => prev + 1)`.

</details>

---

### Q3: `reduce` with Initial Value Nuance
```javascript
const nums = [1, 2, 3];
const result = nums.reduce((acc, curr) => {
  if (curr > 1) acc.push(curr * 2);
  return acc;
}, []); // Note the initial value
```
**What is `result`?**

A) `[2, 4, 6]`
B) `[4, 6]`
C) `6` (Sum)
D) Error: `push` returns length

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: B** `[4, 6]`

**Rationale:**
1.  Initial value is `[]`.
2.  Iteration 1: `curr` is 1. Condition fails. Returns `[]`.
3.  Iteration 2: `curr` is 2. `acc.push(4)`. Returns `[4]`.
4.  Iteration 3: `curr` is 3. `acc.push(6)`. Returns `[4, 6]`.
*Trap:* If you did `return acc.push(...)`, it would fail because `.push()` returns the new length (integer), not the array.

</details>

---

### Q4: Destructuring with Renaming & Defaults
```javascript
const obj = { x: 10, z: 5 };
const { x: newX, y = 20 } = obj;

console.log(x);
```
**What is the output?**

A) `10`
B) `undefined`
C) `ReferenceError`
D) `20`

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: C** `ReferenceError`

**Rationale:** You renamed `x` to `newX`. The variable `x` is **NOT** defined in the current scope. Only `newX` and `y` exist as variables.

</details>

---

### Q5: `JSON.stringify` Data Loss
You try to debug an object by rendering it stringified.
```javascript
const data = {
  id: 1,
  process: () => console.log("running"),
  value: undefined
};
return <div>{JSON.stringify(data)}</div>;
```
**What is rendered?**

A) `{"id":1, "process": "() => ...", "value": undefined}`
B) `{"id":1}`
C) `{"id":1, "value": null}`
D) Error

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: B** `{"id":1}`

**Rationale:** `JSON.stringify` **ignores** (strips out) properties that are `function` or `undefined`. They vanish from the JSON string. `null` would be preserved.

</details>

---

### Q6: The "Short-Circuit" Rendering Math
```javascript
const items = [];
// Scenario: We want to show "No items" if empty.
return (
  <div>
    {items.length && <List data={items} />}
    {!items.length && "No items"}
  </div>
);
```
**What is ACTUALLY rendered when empty?**

A) `No items`
B) `0No items`
C) `falseNo items`
D) Nothing

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: B** `0No items`

**Rationale:**
Line 1: `items.length` is `0`. `0 && <List...>` evaluates to `0`. React renders `0`.
Line 2: `!0` is `true`. `true && "No items"` evaluates to `"No items"`.
Result: `0` + `No items`.
*Fix:* Use `items.length > 0` or ternary operator.

</details>

---

### Q7: Weird Array Keys
```javascript
const arr = ["A", "B"];
arr["2"] = "C";
arr.foo = "D";

console.log(arr.length);
```
**What is the length?**

A) 4
B) 3
C) 2
D) undefined

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: B** `3`

**Rationale:**
1.  Arrays are Objects. You can add properties like `foo`.
2.  `arr["2"]` is a valid numeric index. It extends the array length to 3 (`0, 1, 2`).
3.  `arr.foo` is a property, but **does not affect the length** of the array.

</details>

---

### Q8: `useEffect` Cleanup Timing
```javascript
useEffect(() => {
  console.log("Mount");
  return () => console.log("Unmount");
}, [id]);
// Scenario: id changes from 1 to 2.
```
**What is the console order?**

A) Mount (1) -> Mount (2) -> Unmount (1)
B) Unmount (1) -> Mount (2)
C) Mount (2) -> Unmount (1)
D) Mount (1) -> Unmount (1) -> Mount (2)

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: B** `Unmount (1) -> Mount (2)`

**Rationale:** When a dependency changes:
1.  React cleans up the **previous** effect first (runs the return function with old data).
2.  Then runs the **new** effect (with new data).

</details>

---

### Q9: Object Key Order in `map`
```javascript
const obj = { "2": "a", "1": "b", "b": "c", "a": "d" };
// We map over Object.keys(obj)
```
**What is the likely iteration order of keys?**

A) "2", "1", "b", "a" (Insertion Order)
B) "1", "2", "b", "a" (Numeric sorted, then strings)
C) Random
D) "a", "b", "1", "2" (Alphabetical)

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: B** `"1", "2", "b", "a"`

**Rationale:** This is a deep JS spec rule.
1.  **Integer-like keys** (indices) are sorted ascending first (`"1", "2"`).
2.  **String keys** follow in insertion order (`"b", "a"`).
*Note:* This traps people who think JSON preserves insertion order perfectly.

</details>

---

### Q10: The `filter` + `map` Chain Efficiency
You want to render only active users.
```javascript
// Method A
users.filter(u => u.active).map(u => <div key={u.id}>{u.name}</div>)

// Method B
users.map(u => u.active && <div key={u.id}>{u.name}</div>)
```
**What is the difference in the DOM output?**

A) No difference.
B) Method A renders a clean list; Method B renders `false` holes.
C) Method B renders `null` holes in the DOM.
D) Method B is faster.

<details> <summary style="cursor: pointer; color: #f43f5e; font-weight: bold;">▼ Click to Reveal Answer</summary>

✅ **Correct Answer: A** (Visually) / **B** (Technically)

**Rationale:**
React ignores `false` returned by Method B, so visually they look the same.
**HOWEVER**, Method B creates an array of mixed `JSX` and `false` values (e.g. `[<div>...</div>, false, <div>...</div>]`).
Method A creates a shorter, cleaner array `[<div>...</div>, <div>...</div>]`.
Method A is generally preferred for cleaner keys and index handling.

</details>

---

[ZH]
**做完感觉如何？如果这 10 题你都能解释清楚，明天的考试你就是降维打击。**
**How does it feel? If you can explain these 10, tomorrow's exam will be a piece of cake.**
[END]
